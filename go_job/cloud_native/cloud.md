# Motivation for Cloud native apps
- Three key principles of Cloud native applications
    - BUILT AND COMPOSED
    - PACKAGED AND DISTRIBUTED IN CONTAINERS
    - DYNAMICALLY EXECUTED IN THE CLOUD

- HYPERSCALE 
        - TRAFFIC
        - DATA
        - FEATURES
- ANTIFRAGILITY
    
- CONTINUOUS
> DELIVERY & DEVOPS
    
- OPEX SAVINGS
> automation & utilization

# Challenges and design principles
    
   - Challenges that come with Cloud native application development
   - Design principles of Cloud native applications
        - Design for Performance: Responsive, concurrency, efficiency
        - Design for Automation: Automate dev tasks and ops tasks
        - Design for Resiliency: Fault tolerant and self healing
        - Design for Elasticity: Dynamically scale up and down and be reative
        - Design for Delivery: Short roundtripsand automated delivery
        - Design for Diagnosability: Cluster-wide logs, traces, and metrics

# Decomposition with microservices
- Discussing the components all along the software lifecycle
- Examining the anatomy of an Ops component
- Viewing the microservice decomposition trade-offs

# Cloud Native Stack
- Discussing the anatomy of the Cloud native stack
- Exploring a Cloud native landscape with some key technologies
- Examining the Cloud native stack used for this course

# Simple Go Microservices
- Simple HTTP server implementation in go
- Json marshalling/unmarshalling of go structs
- Simple rest api implementation

- Using the Go net/http package
- Implementing and start a simple HTTP server
- Defining simple handler functions
